{
  "content": [
    {
      "type": "text",
      "text": "# Reddit Posts (2 posts)\n\n**Comment Allocation:** 20 comments/post (2 posts, 1000 total budget)\n**Status:** üì¶ 1 batch(es) processed\n\n---\n\n## What are your favorite TypeScript features or tips you think every developer should know?\n\n**r/typescript** ‚Ä¢ u/P-TownHero ‚Ä¢ ‚¨ÜÔ∏è 84 ‚Ä¢ üí¨ 58 comments\nüîó https://reddit.com/r/typescript/comments/1640uml/what_are_your_favorite_typescript_features_or/\n\n### Post Content\n\nRight now I'm exclusively using TypeScript only to infer types, and to give type definitions via interfaces when TS starts to cry. What are some some features or things that I'm missing out on?\n\n### Top Comments (15/58 shown, allocated: 20)\n\n- **u/CreativeTechGuyGames** _(+125)_\n  Discriminated unions are by far my favorite. Too often people will make types where multiple properties are marked as optional, but in reality, they are dependent and not every permutation is possible. So a discriminated union is the way to indicate exactly which variations of an object can exist.\n  \n  ```\n  // Instead of:\n  type Response = {\n      status: \"loading\" | \"error\" | \"success\";\n      data?: object;\n      error?: Error;\n  };\n  // Do:\n  type Response = {\n      status: \"loading\";\n      data?: undefined;\n      error?: undefined;\n  } | {\n      status: \"error\";\n      data?: undefined;\n      error: Error;\n  } | {\n      status: \"success\";\n      data: object;\n      error?: undefined;\n  };\n  ```\n\n  - **u/30thnight** _(+7)_\n    If you need to create a narrower type from an existing union, you can also exclude a specific discriminated union `Exclude<UnionType, { status: ‚Äúerror‚Äù }>`\n\n- **u/Max-Feige** _(+30)_\n  [Assertion functions](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions) are criminally underused in my opinion, they can be a lot more convenient then throwing type guards everywhere.\n\n- **u/alphabet_american** _(+19)_\n  Generics\n\n- **u/Volbohel** _(+16)_\n  [https://github.com/sindresorhus/type-fest](https://github.com/sindresorhus/type-fest)\n  \n  Bunch of cool type hacks from the repo above. One of my favorite use cases is MergeDeep. I auto generate my types from my backend, but sometimes I need to override very nested types and this helps me do it declaratively!\n\n- **u/Gmun23** _(+15)_\n  `type FuncionsType = ReturnType<typeof SomeFunction>;`\n  \n  this will get a type of a function, so u don't have to type it again, very useful.\n  \n  [https://www.typescriptlang.org/docs/handbook/utility-types.html#returntypetype](https://www.typescriptlang.org/docs/handbook/utility-types.html#returntypetype)\n\n- **u/30thnight** _(+12)_\n  the satisfies operator is incredibly useful for defining objects & really shines with mock data\n\n- **u/denexapp** _(+11)_\n  The main rule I've learned: do not abuse type system and stick to simple types without using advanced features, unless you absolutely have to use advanced types.\n  \n  TypeScript is not very good at being consistent when it comes to advanced types. In many cases you may bump into various limitations, forcing you to cast types, supress errors with ts-ignore, or rewrite your code in a weird way to satisfy TypeScript compiler.\n\n  - **u/Pelopida92** _(+5)_\n    Not only that, but the more complex your types are, the worse the performance of the compiler gets\n\n- **u/zombarista** _(+5)_\n  ‚ÄòRecord<K, V>` is so very handy. It‚Äôs for typing dictionaries such as dict[key] = value. Really handy for typing an object for a reduce.\n  \n  `array.reduce( (res, cur) => {}, {} as Record<string, number> )`\n  \n  But handy in so many other ways. It‚Äôs built in!\n\n  - **u/ninth_reddit_account** _(+12)_\n    `arr.reduce<Record<string, number>>(..., {})`\n    \n    look pa, no type assertions!\n\n  - **u/rcfox** _(+2)_\n    Record is powerful when you use an enum for the key type. It will force you to define a value for each possible key.\n\n- **u/KrisstopherP** _(+5)_\n  [Utility types](https://www.typescriptlang.org/docs/handbook/utility-types.html)\n\n- **u/TheExodu5** _(+5)_\n  Discriminated unions along with type predicates is the simple one.\n  \n  For more complex types, generics + conditional + mapped types with inference powered by declaring a function argument as a generic type.\n\n- **u/sirmd-dorne** _(+4)_\n  One thing that helps me a lot when working on a big project is using declare module. Its really useful because you can scope your types inside the module and you won‚Äôt have the overhead of having to come up with a unique name for a type it could be just Products.Filters for example\n\n\n\n---\n\n## TypeScript stuff I Wish I Knew Earlier\n\n**r/typescript** ‚Ä¢ u/RohanSinghvi1238942 ‚Ä¢ ‚¨ÜÔ∏è 245 ‚Ä¢ üí¨ 70 comments\nüîó https://reddit.com/r/typescript/comments/1lgckvd/typescript_stuff_i_wish_i_knew_earlier/\n\n### Post Content\n\nPicked up TS thinking it‚Äôd just be ‚ÄúJS + types.‚Äù\n\nIt‚Äôs not. It‚Äôs a mindset shift.\n\nSome hard-earned lessons:\n\n* Don‚Äôt overtype everything. Let the compiler infer; it‚Äôs smarter than you think.\n* Avoid enum unless you *really* need it: union types are usually cleaner.\n* Never ignore errors with as many. That‚Äôs just JS in disguise. Learn how generics work: it‚Äôll unlock 80% of advanced patterns.\n\nTS makes you slow at first. But once it clicks? It‚Äôs like building with safety nets and jetpacks. \n\nStill bump into new edge cases almost daily, especially while working on [Alpha](https://dualite.dev/?utm_source=reddit) (an AI dev assistant for React + TS). It's interesting how, even with type safety, the real challenge is often unlearning and relearning, and having a hold of everything learnt.\n\nAnyway, what‚Äôs one TS habit you had to unlearn?\n\n\n\n### Top Comments (19/70 shown, allocated: 20)\n\n- **u/Merry-Lane** _(+123)_\n  About don‚Äôt overtype everything : Yes, for a lot of devs, that‚Äôs neat.\n  \n  But nope, typing explicitly everything (or almost everything) is a valid approach.\n  \n  Anyway, you should still type explicitly some stuff (like return types)\n\n  - **u/name-taken1** _(+32)_\n    Explicit types help a lot with LSP performance. Especially important if you're building a library.\n\n    - **u/TheSaasDev** _(+6)_\n      I‚Äôm so happy I read this, working on a large project LSP lag pisses me off so hard, I‚Äôve done many things to improve it but somehow never considered this which seems like something that should be obvious\n\n    - **u/Glasgesicht** _(+4)_\n      Do you believe the Go-Rewrite might alleviate some of that? Personally, I prefer working with implicit typing a lot, but I've noticed the performance impact even in medium sized projects.\n\n  - **u/politerate** _(+9)_\n    Explicitly typing the variable can discard valuable type information from the assigned value (like for discriminated unions or literal types), which can weaken type safety downstream.\n\n  - **u/TiddoLangerak** _(+3)_\n    As a general rule of thumb, I recommend to at fully type all functions, i.e. arguments + return types, but rely on inference internally. Whomever is calling your function will need to know the types, having them explicitly stated provides necessary documentation. Moreover, it also makes your code more robust to changes: when relying heavily on type inference it can easily happen that when a type signature of something deep down the stack changes that you'll end up with (inferred) type errors far, far removed from this change. It's not uncommon to get hundreds of them. With type signatures at all the method boundary this won't happen, as the type error will be \"caught\" at the first method boundary it encounters, i.e. it's contained to methods directly calling the changed utility.\n\n  - **u/Pestilentio** _(+2)_\n    Duck typing without inference is definitely error prone. If you want to have types, inference is the way to go imo.\n    \n    Other languages with sound type systems and so not-so-sound ones do not even give you the ability to explicitly type.\n\n- **u/_yak** _(+21)_\n  >Don‚Äôt overtype everything. Let the compiler infer; it‚Äôs smarter than you think.\n  \n  While I agree that ts compiler is good at inferring, I still prefer to explicitly annotate return types. Inferred type needs to be computed and on a large project, this can potentially impact build time and IDE performance. Additionally, it's much easier to catch an error when you have an explicit return type.\n  \n  >Avoid enum unless you¬†*really*¬†need it: union types are usually cleaner.\n  \n  Despite all the hate towards enums, I found that most issues with them can be avoided if they are used as simple collections of values. And while union types are cleaner indeed, they don't provide isolation and ease of refactoring like enums. For example we have a large project where among others we use two union types which have a matching value but are completely unrelated otherwise, i.e. they represent different pieces of knowledge that just happen to intersect:\n  \n      type Ford = 'Mustang' | 'Explorer' | 'Ranger'\n      type Fender = 'Mustang' | 'Stratocaster' | 'Telecaster'\n  \n  You have hundreds of files where 'Mustang' is used as a string and you need to change the Ford model to 'Mustang GT'. What do you do? With enum you change one line and call it done. Of course you could use an object for that, but then every time you type a parameter, you have to either use `keyof typeof` or create another type to get a union of object keys:\n  \n      const Ford = {\n        Mustang: 'Mustang',\n        Explorer: 'Explorer',\n        Ranger: 'Ranger',\n      }\n      \n      const getFordModel = (model: keyof typeof Ford) => {...}\n      \n      vs \n      \n      const getFordModel = (model: Ford) => {...}\n  \n  And you use additional memory too, while `const enum` leaves no runtime footprint.  \n  \n  \n  Enums are not perfect - I would never use numeric enums for example. But in general, I find them super convenient.\n\n  - **u/Humble-Persimmon2471** _(+6)_\n    But you can also use an object as an enum and type it. Then you get both native js enums and the union type\n\n    - **u/_yak** _(+4)_\n      Yes, you can do this\n      \n          // Ford.ts\n          export const Ford = {\n            Mustang: 'Mustang',\n            Explorer: 'Explorer',\n            Ranger: 'Ranger',\n          } as const\n          \n          export type Ford = keyof typeof Ford\n          \n          // app.ts\n          import { Ford } from './Ford.ts'\n      \n      and it allows using `Ford` as both a type and a value.\n      \n      But what's the benefint?  The enum declaration is more concise and will not create runtime objects if used with `const`\n\n- **u/ok-computer-x86** _(+9)_\n  This must be AI generated post\n\n- **u/blind-octopus** _(+7)_\n  Got any good resources for learning the patterns involving generics?\n  \n  I feel like that's my biggest weakness with typescript, when I see the generic stuff I can't parse it.\n\n  - **u/mastermindchilly** _(+15)_\n    I can stress enough how good Matt Pocock is at teaching TypeScript concepts in easy to understand ways. \n    \n    https://www.totaltypescript.com/workshops/typescript-generics\n    \n    https://www.totaltypescript.com/typescript-generics-in-three-easy-patterns\n    \n    - - -\n    \n    As to the original question and related to this, I wish folks wouldn‚Äôt start defining genetics using single letter generic names. Be verbose and just append a T to whatever naming. \n    \n    It‚Äôs the same concept as naming variable name. Make them readable and easy to reason about. It‚Äôs more verbose but takes cognitive load off anyone who has to read the code later.\n\n  - **u/Squigglificated** _(+9)_\n    After doing these [type challenges](https://github.com/type-challenges/type-challenges) you will be a generic god.\n\n  - **u/lord_braleigh** _(+2)_\n    Generics are just tricky. The big realization I had is that every generic type is a function that the typechecker runs. The types in the angle brackets are inputs to the function, and then a real type will be outputted.\n    \n    It's more obvious in C++. When you declare a class template,\n    \n    ```\n    template <typename T>\n    class vector<T> {\n    }\n    ```\n    \n    you have not declared any classes yet. The compiler will not make any classes, and `vector<T>` does not show up anywhere in the compiled output.\n    \n    As soon as you declare your first `vector<int>`, C++ runs the template function to generate a `vector<int>` class. And then if you declare a `vector<string>` C++ will run the template again to generate a totally different `vector<string>` class. The two classes won't share any code by default - they're totally separate classes, they just happened to be generated by the same template.\n\n- **u/Odd-Scientist8057** _(+6)_\n  i use enums constantly. I prefer to almost never see strings outside of type files.\n\n- **u/BoBoBearDev** _(+5)_\n  I will keep using enum. Enum ftw.\n\n- **u/javatextbook** _(+4)_\n  Learn the `satisfies` keyword and use it often.\n\n- **u/dashingsauce** _(+2)_\n  In no particular order:\n  - Run tsc, don‚Äôt just rely on editor to surface errors (some only show when you open the problem file).\n  - If you‚Äôre building a library/package/client, use a dedicated type testing library!\n  - There‚Äôs almost certainly an existing type utility that could help you solve whatever type problem you think you need to solve with custom type gymnastics (I found ‚Äútype-fest‚Äù regrettably a year too late)\n  - JSON schema x Typescript is super cool and powerful, especially in the AI era. Power of TS with portability of JSON. Would recommend Typebox (and its Zod/Valibot/etc. mapping library Typemap). \n  - Skim this (or dive in). Great way to learn is to find the patterns across the patterns. Shows a bit of ‚Äúhow TS thinks‚Äù:\n    - [TS Design Patterns](https://refactoring.guru/design-patterns/typescript)\n    - [TS Refactoring](https://refactoring.guru/refactoring)\n  - ‚ÄúThe compiler isn‚Äôt magic, and you can help it do better or worse at its job.‚Äù That‚Äôs what made generics and type utilities click for me.\n  - You can ‚Äúassert‚Äù or ‚Äúsatisfy‚Äù things if you are smarter than the compiler :)\n  - In general, you can offload a lot of future dev labor to the type system if you do it right and do it early.\n  \n  ‚Äî\n  \n  Overall the big realization for me was that Typescript is basically a live parallel environment you can program to increase the odds of writing better code.\n  \n  That idea made it fun‚Äî‚Äúoh! I can probably hack this too üòè‚Äù\n  \n  Also, apparently, you can do anything in Typescript if you‚Äôre obsessive and have a year to kill‚Äîincluding build the original \n  [Doom](https://youtu.be/0mCsluv5FXA?si=dNqQa4Mj8_2JgZ4b)\n\n\n\n---\n\n**Summary:** ‚úÖ 2 successful | ‚ùå 0 failed"
    }
  ]
}